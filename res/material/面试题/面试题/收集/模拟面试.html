<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/><meta name="exporter-version" content="Evernote Mac 6.0.16 (451861)"/><meta name="author" content="zhangzz7998@163.com"/><meta name="created" content="2015-07-06 06:04:30 +0000"/><meta name="source" content="desktop.mac"/><meta name="updated" content="2015-07-19 12:19:59 +0000"/><title>模拟面试</title></head><body>
<div><b>一. 语法</b></div>
<div><b>1.属性</b></div>
<div><b>1&gt;readwrite，readonly，assign，retain，copy，nonatomic属性的作用</b></div>
<div>@property是一个属性访问声明，扩号内支持以下几个属性：</div>
<div>1.1&gt;getter=getterName，setter=setterName，设置setter与getter的方法名</div>
<div>1.2&gt;assign，setter方法直接赋值，不进行任何retain操作，为了解决原类型与循环引用问题</div>
<div>1.3&gt;retain，setter方法对参数进行release旧值再retain新值</div>
<div>1.4&gt;copy，setter方法进行copy操作，与retain处理流程一样，先旧值release，再copy出新的对象，retainCount为1。这是为了减少对上下文的依赖而引入的机制。</div>
<div>copy是在你不希望a和b共享一块内存时会使用到。a和b各自有自己的内存。</div>
<div>1.5&gt;readwrite,readonly，设置可供访问级别</div>
<div>1.6&gt;nonatomic，非原子性访问，不加同步，多线程并发访问会提高性能。注意，如果不加此属性，则默认是两个访问方法都为原子型事务访问。</div>
<div><br/></div>
<div><b>2.copy</b></div>
<div><b>1&gt; copy的使用场景</b></div>
<div>当多个指针指向同一个对象时,为避免一个指针对对象的改动对其他指针的使用产生影响,使用copy来创建对象的副本</div>
<div><b>2&gt; 什么是深拷贝浅拷贝</b></div>
<div>对于非容器类对象,不可变对象进行copy操作为浅拷贝,引用计数器加1,其他三种为深拷贝</div>
<div>对于容器类对象,基本和非容器类对象一致,但注意其深拷贝是对象本身是对象复制,其中元素仍为指针复制,系统将initWithArray方法归为了元素深拷贝,但其实如果元素为不可变元素,仍为指针复制,使用归解档可以实现真正的深拷贝,元素也是对象拷贝NSArray* trueDeepCopyArray = [NSKeyedUnarchiver unarchiveObjectWithData:</div>
<div>    [NSKeyedArchiver archivedDataWithRootObject: array]];</div>
<div><b>3&gt; 字符串为什么用copy</b></div>
<div>防止字符串内容改变影响</div>
<div><b>4&gt; 字符串所在内存区域</b></div>
<div>@“abc” 常量区   stringwithformat 堆区</div>
<div><br/></div>
<div><b>3.block</b></div>
<div><b>1&gt; block属性为什么用copy?</b></div>
<div>栈-&gt;堆</div>
<div><b>2&gt; block使用注意什么?</b></div>
<div>循环引用  修改外部变量</div>
<div><b>3&gt; block的主要使用场景 ?</b></div>
<div>动画</div>
<div>数组字典排序遍历</div>
<div>回调状态</div>
<div>错误控制</div>
<div>多线程GCD</div>
<div><br/></div>
<div><b>4.Swift</b></div>
<div><b>1&gt; Swift和OC的区别</b></div>
<div>1.1&gt; Swift没有地址/指针的概念</div>
<div>1.2&gt; 泛型</div>
<div>1.3&gt; 类型严谨 对比oc的动态绑定</div>
<div><br/></div>
<div><b>5.runtime</b></div>
<div><b>1&gt; 什么是runtime</b></div>
<div>runtime是一套比较底层的纯C语言API, 属于1个C语言库, 包含了很多底层的C语言API。</div>
<div>在我们平时编写的OC代码中, 程序运行过程时, 其实最终都是转成了runtime的C语言代码, runtime算是OC的幕后工作者,objc_msgSend</div>
<div><b>2&gt; runtime干什么用,使用场景</b></div>
<div>runtime是属于OC的底层, 可以进行一些非常底层的操作(用OC是无法现实的, 不好实现)</div>
<div>在程序运行过程中, 动态创建一个类(比如KVO的底层实现)  objc_allocateClassPair，class_addIvar，objc_registerClassPair</div>
<div>在程序运行过程中, 动态地为某个类添加属性\方法, 修改属性值\方法(修改封装的框架)  objc_setAssociatedObject   object_setIvar</div>
<div>遍历一个类的所有成员变量(属性)\所有方法(字典转模型,归解档)  class_copyIvarList class_copyPropertyList  class_copyMethodList</div>
<div><br/></div>
<div><b>6.分类</b></div>
<div><b>1&gt; 分类 拓展 协议中哪些可以声明属性?</b></div>
<div>都可以,但分类和协议创建的属性只相当于方法,但是内部没有对成员变量的操作(无法创建成员变量),拓展可以</div>
<div>代理中声明属性,没有实际创建成员变量,相当于声明了属性名对应的访问方法,遵守协议的类需要实现对应的访问器方法,否则运行报错</div>
<div>分类中声明属性,警告提示需要手动实现访问器方法(Swift中叫计算型属性),而分类中不能创建成员变量,可以在手写访问器方法中使用runtime的 objc_setAssociatedObject方法关联对象间接创建属性(静态库添加属性)</div>
<div>拓展里可以声明属性,直接可以使用</div>
<div><b>2&gt; 继承和类别的区别</b></div>
<div>1&gt; 使用继承:</div>
<div>1.1&gt; 添加新方法和父类方法一致,但父类方法仍需要使用</div>
<div>1.2&gt; 添加新属性</div>
<div>2&gt; 类别:</div>
<div>2.1&gt; 针对系统提供的一些类,系统本身不提倡继承,因为这些类的内部实现对继承有所限制(NSString initWithFormat继承崩溃)</div>
<div>2.2&gt; 类别可以将自己构建的类中的方法进行分组,对于大型的类,提高可维护性</div>
<div><b>3&gt; 分类的作用</b></div>
<div>
<div>将类的实现分散到多个不同文件或多个不同框架中。</div>
<div>创建对私有方法的前向引用。</div>
</div>
<div>向对象添加非正式协议。</div>
<div><b>4&gt; 分类的局限性</b></div>
<div>
<div>无法向类中添加新的实例变量，类别没有位置容纳实例变量。</div>
<div>名称冲突，即当类别中的方法与原始类方法名称冲突时，类别具有更高的优先级。类别方法将完全取代初始方法从而无法再使用初始方法。</div>
</div>
<div>无法添加实例变量的局限可以使用字典对象解决.</div>
<div><br/></div>
<div><br/></div>
<div><b>7.NSArray和NSDictionary</b></div>
<div><b>1&gt; iOS遍历数组/字典的方法</b></div>
<div>数组:  for循环  for in    enumerateObjectsUsingBlock(正序)    enumerateObjectsWithOptions:usingBlock:(多一个遍历选项,不保证顺序)</div>
<div>字典:</div>
<div>1. for(NSString *object in [testDic allValues])</div>
<div>2. for(id akey in [testDic allKeys]){</div>
<div>[sum appendString:[testDic objectForKey:akey]];  }</div>
<div>3. [testDic enumerateKeysAndObjectsUsingBlock:^(idkey,idobj,BOOL*stop) {</div>
<div>        [sum appendString:obj];  } ];</div>
<div>速度:  对于数组, 增强for最快,普通for和block速度差不多,增强最快是因为增强for语法会对容器里的元素的内存地址建立缓冲,遍历的时候直接从缓冲中取元素地址而不是通过调用方法来获取,所以效率高.这也是使用增强for时不能在循环体中修改容器元素的原因之一(可以在循环体中添加标记,在循环体外修改元素)</div>
<div>对于字典,allValues最快,allKey和block差不多,原因是allKey需要做objcetForKey的方法</div>
<div><br/></div>
<div><b>其他</b></div>
<div>nil Nil null NSNull 的区别</div>
<div><br/></div>
<div>二. UI</div>
<div><b>1.生命周期</b></div>
<div>1&gt; 应用的生命周期</div>
<div>各个程序运行状态时代理的回调：</div>
<div>- (BOOL)application:(UIApplication *)application willFinishLaunchingWithOptions:(NSDictionary *)launchOptions  告诉代理进程启动但还没进入状态保存</div>
<div>- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions   告诉代理启动基本完成程序准备开始运行</div>
<div>- (void)applicationWillResignActive:(UIApplication *)application   当应用程序将要入非活动状态执行，在此期间，应用程序不接收消息或事件，比如来电话了</div>
<div>- (void)applicationDidBecomeActive:(UIApplication *)application    当应用程序入活动状态执行，这个刚好跟上面那个方法相反</div>
<div>- (void)applicationDidEnterBackground:(UIApplication *)application   当程序被推送到后台的时候调用。所以要设置后台继续运行，则在这个函数里面设置即可</div>
<div>- (void)applicationWillEnterForeground:(UIApplication *)application   当程序从后台将要重新回到前台时候调用，这个刚好跟上面的那个方法相反。</div>
<div>- (void)applicationWillTerminate:(UIApplication *)application   当程序将要退出是被调用，通常是用来保存数据和一些退出前的清理工作。</div>
<div><img src="%E6%A8%A1%E6%8B%9F%E9%9D%A2%E8%AF%95.resources/78FC2B2E-BBC0-45BB-ACFF-B731B24CF52E.png" height="631" width="532"/></div>
<div><b>2&gt; 视图的生命周期</b></div>
<div>loadView - 默认调用super方法,根据控制器创建方式加载视图,重写后将根据重写方法创建视图</div>
<div>viewDidLoad－视图加载完成</div>
<div>viewWillAppear－UIViewController对象的视图即将加入窗口时调用；</div>
<div>viewDidApper－UIViewController对象的视图已经加入到窗口时调用；</div>
<div>viewWillDisappear－UIViewController对象的视图即将消失、被覆盖或是隐藏时调用；</div>
<div>viewDidDisappear－UIViewController对象的视图已经消失、被覆盖或是隐藏时调用；</div>
<div>viewVillUnload－当内存过低时，需要释放一些不需要使用的视图时，即将释放时调用；</div>
<div>viewDidUnload－当内存过低，释放一些不需要的视图时调用。</div>
<div><b>3&gt;  load initialize方法的区别</b></div>
<div><br/></div>
<table style="-evernote-table:true;border-collapse:collapse;width:100%;table-layout:fixed;">
<tr>
<td style="border-style:solid;border-width:1px;border-color:rgb(211,211,211);padding:10px;margin:0px;width:33.33%;">
<div><br/></div>
</td>
<td style="border-style:solid;border-width:1px;border-color:rgb(211,211,211);padding:10px;margin:0px;width:33.33%;">
<div>+(void)load</div>
</td>
<td style="border-style:solid;border-width:1px;border-color:rgb(211,211,211);padding:10px;margin:0px;width:33.33%;">
<div>+(void)initialize</div>
</td>
</tr>
<tr>
<td style="border-style:solid;border-width:1px;border-color:rgb(211,211,211);padding:10px;margin:0px;width:33.33%;">
<div>执行时机</div>
</td>
<td style="border-style:solid;border-width:1px;border-color:rgb(211,211,211);padding:10px;margin:0px;width:33.33%;">
<div>在程序运行后立即执行</div>
</td>
<td style="border-style:solid;border-width:1px;border-color:rgb(211,211,211);padding:10px;margin:0px;width:33.33%;">
<div>在类的方法第一次被调时执行</div>
</td>
</tr>
<tr>
<td style="border-style:solid;border-width:1px;border-color:rgb(211,211,211);padding:10px;margin:0px;width:33.33%;">
<div>若自身未定义，是否沿用父类的方法？</div>
</td>
<td style="border-style:solid;border-width:1px;border-color:rgb(211,211,211);padding:10px;margin:0px;width:33.33%;">
<div>否</div>
</td>
<td style="border-style:solid;border-width:1px;border-color:rgb(211,211,211);padding:10px;margin:0px;width:33.33%;">
<div>是</div>
</td>
</tr>
<tr>
<td style="border-style:solid;border-width:1px;border-color:rgb(211,211,211);padding:10px;margin:0px;width:33.33%;">
<div>类别中的定义</div>
</td>
<td style="border-style:solid;border-width:1px;border-color:rgb(211,211,211);padding:10px;margin:0px;width:33.33%;">
<div>全都执行，但后于类中的方法</div>
</td>
<td style="border-style:solid;border-width:1px;border-color:rgb(211,211,211);padding:10px;margin:0px;width:33.33%;">
<div>覆盖类中的方法，只执行一个</div>
</td>
</tr>
</table>
<div><b>4&gt; Xib和storyboard创建控制器/视图的方式</b></div>
<div><b>5&gt; frame和bounds的区别</b></div>
<div><b>6&gt; View和layer的区别</b></div>
<div>图层不会直接渲染到屏幕上，UIView是iOS系统中界面元素的基础，所有的界面元素都是继承自它。它本身完全是由CoreAnimation来实现的。它真正的绘图部分，是由一个CALayer类来管理。UIView本身更像是一个CALayer的管理器。一个UIView上可以有n个CALayer，每个layer显示一种东西，增强UIView的展现能力。</div>
<div>6.1&gt;都可以显示屏幕效果</div>
<div>6.2&gt; 如果需要用户交互就要用UIVIew,其可接收触摸事件(继承UIResponder),而CALayer不能接收触摸事件<br/></div>
<div><br/></div>
<div>6.3&gt; 如果没有用户交互可选用CALayer,因为其所在库较小,占用的资源较少</div>
<div><b>7&gt; new和alloc init的区别</b></div>
<div>采用new的方式只能采用默认的init方法完成初始化，采用alloc的方式可以用其他定制的初始化方法。</div>
<div><br/></div>
<div><b>2.UITableview</b></div>
<div><b>1&gt; 自定义高度</b></div>
<div>1.1&gt;新建一个继承自UITableViewCell的类</div>
<div>1.2&gt;重写initWithStyle:reuseIdentifier:方法</div>
<div>1.3&gt;添加所有需要显示的子控件(不需要设置子控件的数据和frame,  子控件要添加到contentView中)</div>
<div>1.4&gt;进行子控件一次性的属性设置(有些属性只需要设置一次, 比如字体\固定的图片)</div>
<div>1.5&gt;提供2个模型</div>
<div>数据模型: 存放文字数据\图片数据</div>
<div>frame模型: 存放数据模型\所有子控件的frame\cell的高度</div>
<div>1.6&gt;cell拥有一个frame模型(不要直接拥有数据模型)</div>
<div>1.7&gt;重写frame模型属性的setter方法: 在这个方法中设置子控件的显示数据和frame</div>
<div><br/></div>
<div><b>3.UICollectionView</b></div>
<div>1&gt; 如何实现瀑布流,流水布局</div>
<div>2&gt; 和UITableView的使用区别</div>
<div><br/></div>
<div><b>3.触摸事件</b></div>
<div><b>1&gt; 描述响应者链条</b></div>
<div>当触摸事件发生时,压力转为电信号,iOS系统将产生UIEvent对象,记录事件产生的时间和类型,然后系统将事件加入到一个由UIApplication管理的事件队列中。</div>
<div>UIApplication会从事件队列中取出最前面的事件，并将事件分发下去以便处理，通常，先发送事件给应用程序的主窗口（keyWindow）</div>
<div>主窗口会在视图层次结构中找到一个最合适的视图来处理触摸事件(从父到子,从后到前)，这也是整个事件处理过程的第一步</div>
<div>找到合适的视图控件后，就会调用视图控件的touches方法来作具体的事件处理</div>
<div>2&gt;</div>
<div><br/></div>
<div><b>三.机制</b></div>
<div><b>1.内存管理</b></div>
<div>1&gt;堆和栈的区别</div>
<div>管理方式：对于栈来讲，是由编译器自动管理，无需我们手工控制；对于堆来说，释放工作由程序员控制，容易产生memory leak。</div>
<div>申请大小：</div>
<div>栈：在Windows下,栈是向低地址扩展的数据结构，是一块连续的内存的区域。这句话的意思是栈顶的地址和栈的最大容量是系统预先规定好的，在 WINDOWS下，栈的大小是2M（也有的说是1M，总之是一个编译时就确定的常数），如果申请的空间超过栈的剩余空间时，将提示overflow。因此，能从栈获得的空间较小。</div>
<div>堆：堆是向高地址扩展的数据结构，是不连续的内存区域。这是由于系统是用链表来存储的空闲内存地址的，自然是不连续的，而链表的遍历方向是由低地址向高地址。堆的大小受限于计算机系统中有效的虚拟内存。由此可见，堆获得的空间比较灵活，也比较大。</div>
<div>碎片问题：</div>
<div>对于堆来讲，频繁的new/delete势必会造成内存空间的不连续，从而造成大量的碎片，使程序效率降低。对于栈来讲，则不会存在这个问题，因为栈是先进后出的队列，他们是如此的一一对应，以至于永远都不可能有一个内存块从栈中间弹出</div>
<div>分配方式：</div>
<div>堆都是动态分配的，没有静态分配的堆。栈有2种分配方式：静态分配和动态分配。静态分配是编译器完成的，比如局部变量的分配。动态分配由alloca函数进行分配，但是栈的动态分配和堆是不同的，他的动态分配是由编译器进行释放，无需我们手工实现。</div>
<div>分配效率：</div>
<div>栈是机器系统提供的数据结构，计算机会在底层对栈提供支持：分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行，这就决定了栈的效率比较高。堆则是C/C++函数库提供的，它的机制是很复杂的。</div>
<div><b>2&gt; 字符串的内存管理</b></div>
<div>创建字符串的内存空间  堆  常量区</div>
<div><b>3&gt; OC和C框架对象引用</b></div>
<div>oc和c 桥接 三个桥接关键字都是干么的 __bridge  不更改归属权  __bridge_transfer 所有权给OC   __bridge_retain 解除OC的所有权</div>
<div><b>4&gt; 循环引用</b></div>
<div>delegate属性的内存策略  block循环引用</div>
<div><b>5&gt; autorelease的使用   工厂方法为什么不释放对象  ARC下autorelease的使用场景</b></div>
<div>避免内存峰值</div>
<div>SDWebimage中加载gif图片  大循环</div>
<div>栈结构 栈顶</div>
<div>统一发release消息</div>
<div><br/></div>
<div><b>2.KVC和KVO</b></div>
<div><b>1&gt; 如何调用私有变量</b>    <b>如何修改系统的只读属性</b>    <b>KVC的查找顺序</b></div>
<div>KVC在某种程度上提供了访问器的替代方案。不过访问器方法是一个很好的东西，以至于只要是有可能，KVC也尽量再访问器方法的帮助下工作。为了设置或者返回对象属性，KVC按顺序使用如下技术：</div>
<div>①检查是否存在-&lt;key&gt;、-is&lt;key&gt;（只针对布尔值有效）或者-get&lt;key&gt;的访问器方法，如果有可能，就是用这些方法返回值；</div>
<div>检查是否存在名为-set&lt;key&gt;:的方法，并使用它做设置值。对于 -get&lt;key&gt;和 -set&lt;key&gt;:方法，将大写Key字符串的第一个字母，并与Cocoa的方法命名保持一致；</div>
<div>②如果上述方法不可用，则检查名为-_&lt;key&gt;、-_is&lt;key&gt;（只针对布尔值有效）、-_get&lt;key&gt;和-_set&lt;key&gt;:方法；</div>
<div>③如果没有找到访问器方法，可以尝试直接访问实例变量。实例变量可以是名为：&lt;key&gt;或_&lt;key&gt;;</div>
<div>④如果仍为找到，则调用valueForUndefinedKey:和setValue:forUndefinedKey:方法。这些方法的默认实现都是抛出异常，我们可以根据需要重写它们。</div>
<div><b>2&gt; 什么是键-值,键路径是什么</b></div>
<div>模型的性质是通过一个简单的键（通常是个字符串）来指定的。视图和控制器通过键来查找相应的属性值。在一个给定的实体中，同一个属性的所有值具有相同的数据类型。键-值编码技术用于进行这样的查找—它是一种间接访问对象属性的机制。</div>
<div>键路径是一个由用点作分隔符的键组成的字符串，用于指定一个连接在一起的对象性质序列。第一个键的性质是由先前的性质决定的，接下来每个键的值也是相对于其前面的性质。键路径使您可以以独立于模型实现的方式指定相关对象的性质。通过键路径，您可以指定对象图中的一</div>
<div>个任意深度的路径，使其指向相关对象的特定属性。</div>
<div><b>3&gt; 什么是KVC和KVO</b></div>
<div>KVC(Key-Value-Coding)内部的实现：一个对象在调用setValue的时候，（1）首先根据方法名找到运行方法的时候所需要的环境参数。（2）他会从自己isa指针结合环境参数，找到具体的方法实现的接口。（3）再直接查找得来的具体的方法实现。KVO（Key-Value- Observing）：当观察者为一个对象的属性进行了注册，被观察对象的isa指针被修改的时候，isa指针就会指向一个中间类，而不是真实的类。所以 isa指针其实不需要指向实例对象真实的类。所以我们的程序最好不要依赖于isa指针。在调用类的方法的时候，最好要明确对象实例的类名</div>
<div><b>4&gt; kvo的实现机制</b></div>
<div>
<div>当某个类的对象第一次被观察时，系统就会在运行时动态地创建该类的一个派生类，在这个派生类中重写原类中被观察属性的setter方法,派生类在被重写的setter方法实现真正的通知机制(Person-&gt;NSKVONotifying_Person).</div>
</div>
<div>派生类重写了 class 方法以“欺骗”外部调用者它就是起初的那个类。然后系统将这个对象的isa指针指向这个新诞生的派生类，因此这个对象就成为该派生类的对象了，因而在该对象上对setter的调用就会调用重写的setter，从而激活键值通知机制。此外，派生类还重写了dealloc方法来释放资源。</div>
<div><b>5&gt; kvo使用场景</b></div>
<div>①实现上下拉刷新控件 contentoffset</div>
<div>②webview混合排版 contentsize</div>
<div>③监听模型属性实时更新UI</div>
<div><br/></div>
<div><b>3.消息机制</b></div>
<div><b>1&gt; 消息转发的原理</b></div>
<div>当向一个对象发送消息时，objc_msgSend方法根据对象的isa指针找到对象的类，然后在类的调度表（dispatch table）中查找selector。如果无法找到selector，objc_msgSend通过指向父类的指针找到父类，并在父类的调度表（dispatch table）中查找selector，以此类推直到NSObject类。一旦查找到selector，objc_msgSend方法根据调度表的内存地址调用该实现。 通过这种方式，message与方法的真正实现在执行阶段才绑定。</div>
<div>    为了保证消息发送与执行的效率，系统会将全部selector和使用过的方法的内存地址缓存起来。每个类都有一个独立的缓存，缓存包含有当前类自己的 selector以及继承自父类的selector。查找调度表（dispatch table）前，消息发送系统首先检查receiver对象的缓存。</div>
<div> 缓存命中的情况下，消息发送（messaging）比直接调用方法（function call）只慢一点点点点。</div>
<div><b>2&gt; SEL isa super cmd 是什么</b></div>
<div>sel: 一种类型,表示方法名称,类似字符串(可互转)</div>
<div>isa:在方法底层对应的objc_msgSend调用时,会根据isa找到对象所在的类对象,类对象中包含了调度表(dispatch table),该表将类的sel和方法的实际内存地址关联起来</div>
<div>super_class:每一个类中还包含了一个super_class指针,用来指向父类对象</div>
<div>_cmd在Objective-C的方法中表示当前方法的selector，正如同self表示当前方法调用的对象实例</div>
<div>IMP定义为 id (*IMP) (id, SEL, …)。这样说来， IMP是一个指向函数的指针，这个被指向的函数包括id(“self”指针)，调用的SEL（方法名），再加上一些其他参数.说白了IMP就是实现方法</div>
<div><b>3&gt; 动态绑定</b></div>
<div>—在运行时确定要调用的方法</div>
<div>动态绑定将调用方法的确定也推迟到运行时。在编译时，方法的 调用并不和代码绑定在一起，只有在消实发送出来之后，才确定被调用的代码。通过动态类型和动态绑定技术，您的代码每次执行都可以得到不同的结果。运行时因 子负责确定消息的接收者和被调用的方法。运行时的消息分发机制为动态绑定提供支持。当您向一个动态类型确定了的对象发送消息时，运行环境系统会通过接收者 的isa指针定位对象的类，并以此为起点确定被调用的方法，方法和消息是动态绑定的。而且，您不必在Objective-C 代码中做任何工作，就可以自动获取动态绑定的好处。您在每次发送消息时，特别是当消息的接收者是动态类型已经确定的对象时，动态绑定就会例行而透明地发生。</div>
<div><b>4&gt; 什么时候用delegate，什么时候用Notification</b></div>
<div>delegate针对one-to-one关系，并且reciever可以返回值给sender，notification 可以针对one-to-one/many/none,reciever无法返回值给sender.所以,delegate用于sender希望接受到 reciever的某个功能反馈值，notification用于通知多个object某个事件。</div>
<div>5&gt; delegate和block</div>
<div>block使代码更紧凑,便于阅读,delegate可以设置必选和可选的方法实现,相比block</div>
<div><b>5&gt; 通知的内存管理 线程问题</b></div>
<div><br/></div>
<div><b>4.Runloop</b></div>
<div>1&gt; 每个线程上都有一个runloop,主线程默认开启,辅助线程需要手动开启,主要用于</div>
<ol>
<li>使用端口或自定义输入源来和其他线程通信</li>
<li>使用线程的定时器</li>
<li>Cocoa中使用任何performSelector…的方法</li>
<li>使线程周期性工作</li>
</ol>
<div><br/></div>
<div><b>5.数据存储</b></div>
<div>
<div><b>1&gt; 数据存储的几种方式</b></div>
<div>1.1&gt; plist xml</div>
<div>1.2&gt; 偏好设置</div>
</div>
<div>1.3&gt; 归档  Document 自定义对象 NSCoding协议  </div>
<div>如何使用plist保存视图尺寸 NSValue</div>
<div>
<div><b>2&gt; 沙盒目录结构</b></div>
<div>2.1&gt; Library Caches Preferences</div>
<div>2.2&gt; Documents</div>
</div>
<div>2.3&gt; tmp</div>
<div><br/></div>
<div><b>6.设计模式</b></div>
<div><b>1&gt; 常用的设计模式</b></div>
<div>  代理  观察者  工厂  单例   策略</div>
<div>2&gt; 代理属性的内存策略是什么,为什么?</div>
<div>3&gt; 观察者模式的使用场景</div>
<div>4&gt; 工厂模式(类方法)为什么没有释放对象? autorelease工作原理? arc下还需要手动使用autorelease吗?为什么?什么场景?</div>
<div>5&gt; 手写单例</div>
<div>6&gt; 策略  cell多种响应效果   代理方法</div>
<div><br/></div>
<div><b>四.多线程</b></div>
<div><b>1&gt; 在多线程中使用通知需要注意什么问题?</b></div>
<div><b>2&gt; 资源抢夺解决方案</b></div>
<div>@sychronized{ }</div>
<div>dispatch_barrier_async</div>
<div><b>3&gt; 对比iOS中的多线程技术</b></div>
<div>3.1&gt; GCD是纯C语言的API，NSOperationQueue是基于GCD的OC版本封装</div>
<div>3.2&gt; GCD仅仅支持FIFO队列，只可以设置队列的优先级,而NSOperationQueue中的每一个任务都可以被重新设置优先级(setQueuePriority:)，从而实现不同操作的执行顺序调整</div>
<div>3.3&gt; GCD不支持异步操作之间的依赖关系设置。如果某个操作的依赖另一个操作的数据，使用NSOperationQueue能够设置依赖按照正确的顺序执行操作(addDependency:)。GCD则没有内建的依赖关系支持(只能通过Barrior和同步任务手动实现)。</div>
<div>3.4&gt; NSOperationQueue方便停止队列中的任务(cancelAllOperations, suspended),GCD不方便停止队列中的任务.</div>
<div>3.5&gt; NSOperationQueue支持KVO，可以监测operation是否正在执行（isExecuted）、是否结束（isFinished），是否取消（isCanceld）</div>
<div>3.6&gt; GCD的执行速度比NSOperationQueue快</div>
<div>3.7&gt; NSOperationQueue可设置最大并发数量(节电),GCD具有dispatch_once(只执行一次,单例)和dispatch_after(延迟执行)功能</div>
<div>3.8&gt; NSObject分类和NSThread遇到对象分配需要手动内存管理</div>
<div>3.9&gt; NSThread查看线程</div>
<div>3.10&gt; NSObject分类线程通信,</div>
<div><b>4&gt; 原子属性</b></div>
<div>原子属性采用的是"多读单写"机制的多线程策略</div>
<div>"多读单写"缩小了锁范围,比互斥锁的性能好</div>
<div>规定只在主线程更新UI,就是因为如果在多线程中更新,就需要给UI对象加锁,防止资源抢占写入错误,但是这样会降低UI交互的性能,所以ios设计让所有UI对象都是非线程安全的(不加锁),并规定只在主线程中更新UI,规避多线程抢占资源问题</div>
<div><b>5&gt; 多线程优缺点</b></div>
<div>优点:</div>
<div>使应用程序的响应速度更快,用户界面在进行其他工作的同时仍始终保持活动状态;</div>
<div>优化任务执行,适当提高资源利用率(cpu, 内存);</div>
<div>缺点:</div>
<div>线程占用内存空间,管理线程需要额外的CPU开销,开启大量线程,降低程序性能;</div>
<div>增加程序复杂度,如线程间通信,多线程的资源共享等;</div>
<div><br/></div>
<div><b>五.网络</b></div>
<div><b>1.数据解析</b></div>
<div><b>1&gt; XML解析方式</b></div>
<div>SAX 方式解析</div>
<div>－只读</div>
<div>－速度快</div>
<div>－从上向下</div>
<div>－通过5个代理方法解析，每个代理方中都需要写一些代码！</div>
<div>－如果要实现SAX解析，思路最重要！</div>
<div>－适合比价大的XML的解析</div>
<div>DOM解析的特点</div>
<div>－一次性将XML全部加载到内存，以树形结构</div>
<div>－好处，可以动态的修改，添加，删除节点</div>
<div>－内存消耗非常大！尤其横向节点越深！</div>
<div>－iOS默认不支持 DOM 解析！</div>
<div>－在 MAC 端，或者服务器端开发，都基本上使用 DOM 解析</div>
<div>－在 iOS 端如果需要使用 DOM 方式解析，可以使用第三方框GData/KissXML(XMPP)</div>
<div>－适合比较小的 XML 文件</div>
<div>－在 MAC 中，苹果提供了一个 NSXML 的类，能够做 DOM 解析，在 iOS 不能使用！</div>
<div><br/></div>
<div><b>2.网络协议</b></div>
<div><b>1&gt;TCP如何防止乱序和丢包</b></div>
<div>    TCP数据包的头格式中有两个概念,Sequence Number是数据包的序号，用来解决网络包乱序（reordering）问题。Acknowledgement Number就是ACK——用于确认收到，用来解决不丢包的问题。</div>
<div>    位码即tcp标志位，有6种标示：SYN(synchronous建立联机)        ACK(acknowledgement 确认) PSH(push传送) FIN(finish结束) RST(reset重置) URG(urgent紧急)Sequence number(顺序号码) Acknowledge number(确认号码).</div>
<div>   SeqNum的增加是和传输的字节数相关的,TCP传输数据时,A主机第一次传输1440个字节,seq=1,那么第二次时seq = 1441,B拼接数据就是根据seq进行拼接的,seq数字不断累加避免了乱序.B主机收到第一次数据包以后会返回ack = 1441.</div>
<div>    A主机收到B的ack = 1441时,就知道第一个数据包B已收到. 如果B没有收到第一次的数据包,那么B再收到A的数据包时,他就会发ack = 1回去,A收到B的回复,发现B没有收到第一次数据包,就会重发第一次数据包,这样就可以防止丢包.</div>
<div><br/></div>
<div><b>2&gt;描述一下三次握手</b></div>
<div><img src="%E6%A8%A1%E6%8B%9F%E9%9D%A2%E8%AF%95.resources/4A0B41CB-FC99-4F95-9586-9FCDE172E30B.png" height="665" width="476"/></div>
<div>   第一次握手：建立连接时，客户端发送syn包(syn=j)到服务器，并进入SYN_SEND状态，等待服务器确认；</div>
<div>   第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；</div>
<div>   第三次握手：客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=k+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。完成三次握手，客户端与服务器开始传送数据.</div>
<div><br/></div>
<div><b>3&gt; TCP与UDP的区别：</b></div>
<div>3.1&gt;基于连接与无连接；</div>
<div>3.2&gt;对系统资源的要求（TCP较多，UDP少）；</div>
<div>3.3&gt;UDP程序结构较简单；</div>
<div>3.4&gt;流模式与数据报模式 ；</div>
<div>3.5&gt;TCP保证数据正确性，UDP可能丢包，TCP保证数据顺序，UDP不保证。</div>
<div><br/></div>
<div><b>4&gt;http和scoket通信的区别</b></div>
<div>http是客户端用http协议进行请求，发送请求时候需要封装http请求头，并绑定请求的数据，服务器一般有web服务器配合（当然也非绝对）。 http请求方式为客户端主动发起请求，服务器才能给响应，一次请求完毕后则断开连接，以节省资源。服务器不能主动给客户端响应（除非采取http长连接技术）。iphone主要使用类是NSUrlConnection。</div>
<div>scoket是客户端跟服务器直接使用socket“套接字”进行连接，并没有规定连接后断开，所以客户端和服务器可以保持连接通道，双方都可以主动发送数据。一般在游戏开发或股票开发这种要求即时性很强并且保持发送数据量比较大的场合使用。主要使用类是CFSocketRef。</div>
<div><br/></div>
<div><b>3.网络传输</b></div>
<div>1&gt;DNS是如何工作的</div>
<div>DNS是domain name server的简称,每个网络的计算机都有ip,但是不好记,所以用域名替代(如www.baidu.com),在 Internet 上真实在辨识机器的还是 IP，所以当使用者输入Domain Name 后，浏览器必须要先去一台有 Domain Name 和IP 对应资料的主机去查询这台电脑的 IP，而这台被查询的主机，我们称它为 Domain Name Server，简称DNS，例如：当你输入www.pchome.com.tw时，浏览器会将www.pchome.com.tw这个名字传送到离他最近的 DNS Server 去做辨识，如果查到，则会传回这台主机的 IP，进而跟它索取资料，但如果没查到，就会发生类似 DNS NOT FOUND 的情形，所以一旦DNS Server当机，就像是路标完全被毁坏，没有人知道该把资料送到那里</div>
<div><br/></div>
<div><b>4.iOS网络框架</b></div>
<div>1&gt; NSURLConnection和NSURLSession的区别</div>
<div>1.1&gt; 异步请求不需要NSOperation包装</div>
<div>1.2&gt; 支持后台运行的网络任务(后台上传下载)</div>
<div>1.3&gt;</div>
<div><br/></div>
<div><b>六.框架</b></div>
<div><b>1.SDWebimage</b></div>
<div>1&gt; SDWebimage的缓存机制</div>
<div>位运算</div>
<div>NSCache</div>
<div>特点: a&gt; 线程安全的 b&gt; 当内存不足的时候,自动释放 c&gt; 缓存数量和缓存成本</div>
<div>区别NSMutableDictionary</div>
<div>1&gt; 不能也不应该遍历  2&gt; NSCache对key强引用,NSMutableDictionary对key进行copy</div>
<div><br/></div>
<div><b>2.AFN</b></div>
<div>传递指针 如何使一个方法返回多个返回值</div>
<div><br/></div>
<div><b>七.项目</b></div>
<div>arc mrc混编</div>
<div>c c++混编</div>
<div>字符串操作  append  format  substring  rangeofstring    nsrange</div>
<div>静态库</div>
<div>如何给静态库添加属性   分类+runtime</div>
<div>如何调用私有方法  performselector  category(前向引用)</div>
<div><br/></div>
<div><br/></div>
<div><b>八.算法</b></div>
<div>交换数值的几种方法  中间变量  加减法   异或</div>
<div>二叉树</div>
<div>链表</div>
<div>递归</div>
</body></html>