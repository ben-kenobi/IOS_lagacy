<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml" lang="zh-cn" xml:lang="zh-cn">
  <head>
    <title>Protocol Extension | Swifter - 100 个 Swift 必备 Tips (第二版)</title>
    <meta content="" name="description"/>
    <meta content="GitBook 2.2.0" name="generator"/>
    <meta content="王巍 (onevcat)" name="author"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="page_styles.css" rel="stylesheet" type="text/css"/>
</head>
  <body class="calibre">
        
        
<div class="page">
    <h1 class="book-chapter" id="calibre_toc_39">Protocol Extension</h1>
    
        <div class="normal" id="section-">
        
            <h1 id="protocol-extension" class="calibre1">Protocol Extension</h1>
<p class="calibre9">Swift 2 中引入了一个非常重要的特性，那就是 protocol extension。在 Swift 1.x 中，extension 仅只能作用在实际的类型上 (也就是 <code class="calibre13 pcalibre6 pcalibre5">class</code>, <code class="calibre13 pcalibre6 pcalibre5">struct</code> 等等)，而不能扩展一个 protocol。但是 Swift 的功能实现基本都是基于 protocol 来构建的，举个最简单的例子，我们每天使用的 <code class="calibre13 pcalibre6 pcalibre5">Array</code> 就是遵守了 <code class="calibre13 pcalibre6 pcalibre5">CollectionType</code> 这个 protocol 的。<code class="calibre13 pcalibre6 pcalibre5">CollectionType</code> 可以说是 Swift 中非常重要的接口，除了 <code class="calibre13 pcalibre6 pcalibre5">Array</code> 以外，像是 <code class="calibre13 pcalibre6 pcalibre5">Dictionary</code> 和 <code class="calibre13 pcalibre6 pcalibre5">Set</code> 也实现了这个接口所定义的内容。</p>
<p class="calibre9">在 protocol 不能被扩展的时候，当我们想要为实现了某个接口的类型所有类型添加一些另外的共通的功能时，会非常麻烦。一个很好的例子是 Swift 1.x 时的像是 <code class="calibre13 pcalibre6 pcalibre5">map</code> 或者 <code class="calibre13 pcalibre6 pcalibre5">filter</code> 这样的函数。大体来说，我们有两种思路进行添加：第一种方式是在接口中定义这个方法，然后在所有实现了这个接口的类型中都去实现一遍。每有一个这样的类型，我们就需要写一份类似甚至相同的方法，这显然是很麻烦的，而且完全没有可维护性。另一种方法是在全局范围实现一个接收这个 protocol 的方法，相比于前一种方式，我们只需要维护一份代码，显然要好不少，但是缺点在于在全局作用域中引入了只和特定 protocol 有关的东西，这也不符合代码设计的美学。作为妥协，Apple 在 Swift 1.x 中采用的是全局方法，如果你尝试寻找的话，可以在标准库的全局 scope 中找到像是 <code class="calibre13 pcalibre6 pcalibre5">map</code> 和 <code class="calibre13 pcalibre6 pcalibre5">filter</code> 这样的方法。</p>
<p class="calibre9">在 Swift 2 中这个问题被彻底解决了。现在我们可以对一个已有的 protocol 进行扩展，而扩展中实现的方法将作为实现扩展的类型的默认实现。也就是说，假设我们有下面的 protocol 声明，以及一个对该接口的扩展：</p>
<pre class="calibre12"><code class="pcalibre3 lang-swift pcalibre4"><span class="hljs-func"><span class="hljs-keyword">protocol</span> <span class="hljs-title">MyProtocol</span> </span>{
    <span class="hljs-func"><span class="hljs-keyword">func</span> <span class="hljs-title">method</span><span class="hljs-params">()</span></span>
}

<span class="hljs-func"><span class="hljs-keyword">extension</span> <span class="hljs-title">MyProtocol</span> </span>{
    <span class="hljs-func"><span class="hljs-keyword">func</span> <span class="hljs-title">method</span><span class="hljs-params">()</span></span> {
        <span class="hljs-params">print</span>(<span class="hljs-string">"Called"</span>)
    }
}
</code></pre>
<p class="calibre9">在具体的实现这个接口的类型中，即使我们什么都不写，也可以编译通过。进行调用的话，会直接使用 extension 中的实现：</p>
<pre class="calibre12"><code class="pcalibre3 lang-swift pcalibre4"><span class="hljs-func"><span class="hljs-keyword">struct</span> <span class="hljs-title">MyStruct</span>: <span class="hljs-title">MyProtocol</span> </span>{

}

<span class="hljs-func">MyStruct</span>().method()
<span class="hljs-title">// 输出：</span>
<span class="hljs-title">// Called in extension</span>
</code></pre>
<p class="calibre9">当然，如果我们需要在类型中进行其他实现的话，可以像以前那样在具体类型中添加这个方法：</p>
<pre class="calibre12"><code class="pcalibre3 lang-swift pcalibre4"><span class="hljs-func"><span class="hljs-keyword">struct</span> <span class="hljs-title">MyStruct</span>: <span class="hljs-title">MyProtocol</span> </span>{
    <span class="hljs-func"><span class="hljs-keyword">func</span> <span class="hljs-title">method</span><span class="hljs-params">()</span></span> {
        <span class="hljs-params">print</span>(<span class="hljs-string">"Called in struct"</span>)
    }
}

<span class="hljs-func">MyStruct</span>().method()
<span class="hljs-title">// 输出：</span>
<span class="hljs-title">// Called in struct</span>
</code></pre>
<p class="calibre9">也就是说，protocol extension 为 protocol 中定义的方法提供了一个默认的实现。c有了这个特性以后，之前被放在全局环境中的接受 <code class="calibre13 pcalibre6 pcalibre5">CollectionType</code> 的 <code class="calibre13 pcalibre6 pcalibre5">map</code> 方法，就可以被移动到 <code class="calibre13 pcalibre6 pcalibre5">CollectionType</code> 的接口扩展中去了：</p>
<pre class="calibre12"><code class="pcalibre3 lang-swift pcalibre4"><span class="hljs-func"><span class="hljs-keyword">extension</span> <span class="hljs-title">CollectionType</span> </span>{
    public <span class="hljs-func"><span class="hljs-keyword">func</span> <span class="hljs-title">map</span><span class="hljs-func">&lt;T&gt;</span><span class="hljs-params">(@noescape transform: <span class="hljs-params">(<span class="hljs-keyword">Self</span>.Generator.Element)</span></span></span> -&gt; <span class="hljs-func">T</span>) -&gt; [<span class="hljs-func">T</span>]
    <span class="hljs-title">//...</span>
}
</code></pre>
<p class="calibre9">在日常开发中，另一个可以用到 protocol extension 的地方是 optional 的接口方法。关于这一点，我们在<a href="objc-protocol.html" class="pcalibre pcalibre2 pcalibre1 calibre4">可选接口和接口扩展</a>一节中已经讲述过，就不再重复了。</p>
<p class="calibre9">对于 protocol extension 来说，有一种会非常让人迷惑的情况，就是在接口的扩展中实现了接口里没有定义的方法时的情况。举个例子，比如我们定义了这样的一个接口和它的一个扩展：</p>
<pre class="calibre12"><code class="pcalibre3 lang-swift pcalibre4"><span class="hljs-func"><span class="hljs-keyword">protocol</span> <span class="hljs-title">A1</span> </span>{
    <span class="hljs-func"><span class="hljs-keyword">func</span> <span class="hljs-title">method1</span><span class="hljs-params">()</span></span> -&gt; <span class="hljs-func">String</span>
}

<span class="hljs-func"><span class="hljs-keyword">struct</span> <span class="hljs-title">B1</span>: <span class="hljs-title">A1</span> </span>{
    <span class="hljs-func"><span class="hljs-keyword">func</span> <span class="hljs-title">method1</span><span class="hljs-params">()</span></span> -&gt; <span class="hljs-func">String</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-string">"hello"</span>
    }
}
</code></pre>
<p class="calibre9">在使用的时候，无论我们将实例的类型为 A1 还是 B1，因为实现只有一个，所以没有任何疑问，调用方法时的输出都是 “hello”：</p>
<pre class="calibre12"><code class="pcalibre3 lang-swift pcalibre4"><span class="hljs-keyword">let</span> b1 = <span class="hljs-func">B1</span>() <span class="hljs-title">// b1 is B1</span>
b1.method1()
<span class="hljs-title">// hello</span>

<span class="hljs-keyword">let</span> a1: <span class="hljs-func">A1</span> = <span class="hljs-func">B1</span>()
<span class="hljs-title">// a1 is A1</span>
a1.method1()
<span class="hljs-title">// hello</span>
</code></pre>
<p class="calibre9">但是如果在接口里只定义了一个方法，而在接口扩展中实现了额外的方法的话，事情就变得有趣起来了。考虑下面这组接口和它的扩展：</p>
<pre class="calibre12"><code class="pcalibre3 lang-swift pcalibre4"><span class="hljs-func"><span class="hljs-keyword">protocol</span> <span class="hljs-title">A2</span> </span>{
    <span class="hljs-func"><span class="hljs-keyword">func</span> <span class="hljs-title">method1</span><span class="hljs-params">()</span></span> -&gt; <span class="hljs-func">String</span>
}

<span class="hljs-func"><span class="hljs-keyword">extension</span> <span class="hljs-title">A2</span> </span>{
    <span class="hljs-func"><span class="hljs-keyword">func</span> <span class="hljs-title">method1</span><span class="hljs-params">()</span></span> -&gt; <span class="hljs-func">String</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-string">"hi"</span>
    }

    <span class="hljs-func"><span class="hljs-keyword">func</span> <span class="hljs-title">method2</span><span class="hljs-params">()</span></span> -&gt; <span class="hljs-func">String</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-string">"hi"</span>
    }
}
</code></pre>
<p class="calibre9">扩展中除了实现接口定义的 <code class="calibre13 pcalibre6 pcalibre5">method1</code> 之外，还定义了一个接口中不存在的方法 <code class="calibre13 pcalibre6 pcalibre5">method2</code>。我们尝试来实现这个接口：</p>
<pre class="calibre12"><code class="pcalibre3 lang-swift pcalibre4"><span class="hljs-func"><span class="hljs-keyword">struct</span> <span class="hljs-title">B2</span>: <span class="hljs-title">A2</span> </span>{
    <span class="hljs-func"><span class="hljs-keyword">func</span> <span class="hljs-title">method1</span><span class="hljs-params">()</span></span> -&gt; <span class="hljs-func">String</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-string">"hello"</span>
    }

    <span class="hljs-func"><span class="hljs-keyword">func</span> <span class="hljs-title">method2</span><span class="hljs-params">()</span></span> -&gt; <span class="hljs-func">String</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-string">"hello"</span>
    }
}
</code></pre>
<p class="calibre9"><code class="calibre13 pcalibre6 pcalibre5">B2</code> 中实现了 <code class="calibre13 pcalibre6 pcalibre5">method1</code> 和 <code class="calibre13 pcalibre6 pcalibre5">method2</code>。接下来，我们尝试初始化一个 <code class="calibre13 pcalibre6 pcalibre5">B2</code> 对象，然后对这两个方法进行调用：</p>
<pre class="calibre12"><code class="pcalibre3 lang-swift pcalibre4"><span class="hljs-keyword">let</span> b2 = <span class="hljs-func">B2</span>()

b2.method1() <span class="hljs-title">// hello</span>
b2.method2() <span class="hljs-title">// hello</span>
</code></pre>
<p class="calibre9">结果在我们的意料之中，虽然在 protocol extension 中已经实现了这两个方法，但是它们只是默认的实现，我们在具体实现接口的类型中可以对默认实现进行覆盖，这非常合理。但是如果我们稍作改变，在上面的代码后面继续添加：</p>
<pre class="calibre12"><code class="pcalibre3 lang-swift pcalibre4"><span class="hljs-keyword">let</span> a2 = b2 <span class="hljs-keyword">as</span> <span class="hljs-func">A2</span>

a2.method1() <span class="hljs-title">// hello</span>
a2.method2() <span class="hljs-title">// hi</span>
</code></pre>
<p class="calibre9"><code class="calibre13 pcalibre6 pcalibre5">a2</code> 和 <code class="calibre13 pcalibre6 pcalibre5">b2</code> 是同一个对象，只不过我们通过 <code class="calibre13 pcalibre6 pcalibre5">as</code> 告诉编译器我们在这里需要的类型是 <code class="calibre13 pcalibre6 pcalibre5">A2</code>。但是这时候在这个同样的对象上调用同样的方法调用却得到了不同的结果，发生了什么？</p>
<p class="calibre9">我们可以看到，对 <code class="calibre13 pcalibre6 pcalibre5">a2</code> 调用 <code class="calibre13 pcalibre6 pcalibre5">method2</code> 实际上是接口扩展中的方法被调用了，而不是 <code class="calibre13 pcalibre6 pcalibre5">a2</code> 实例中的方法被调用。我们不妨这样来理解：对于 <code class="calibre13 pcalibre6 pcalibre5">method1</code>，因为它在 <code class="calibre13 pcalibre6 pcalibre5">protocol</code> 中被定义了，因此对于一个被声明为遵守接口的类型的实例 (也就是对于 <code class="calibre13 pcalibre6 pcalibre5">a2</code>) 来说，可以确定实例必然实现了 <code class="calibre13 pcalibre6 pcalibre5">method1</code>，我们可以放心大胆地用动态派发的方式使用最终的实现 (不论它是在类型中具体实现的还是在接口扩展中的默认实现)；但是对于 <code class="calibre13 pcalibre6 pcalibre5">method3</code> 来说，我们只是在接口扩展中进行了定义，没有任何规定说它必须在最终的类型中被实现。在使用时，因为 <code class="calibre13 pcalibre6 pcalibre5">a2</code> 只是一个符合 <code class="calibre13 pcalibre6 pcalibre5">A2</code> 的实例，编译器对 <code class="calibre13 pcalibre6 pcalibre5">method2</code> 唯一能确定的只是在接口扩展中有一个默认实现，因此在调用时，因为无法确定安全，也就不会去进行动态派发，而是转而编译期间就确定的默认实现。</p>
<p class="calibre9">也许在这个例子中你会觉得无所谓，因为实际中估计并不会有人将一个已知类型实例转回接口类型。但是要考虑到如果你的一些泛型 API 中有类似的直接拿到一个接口类型的结果的时候，调用它的扩展方法时就需要特别小心了：一般来说，如果有这样的需求的话，我们可以考虑将这个接口类型再转回实际的类型，然后进行调用。</p>
<p class="calibre9">整理一下相关的规则的话：</p>
<ul class="calibre19">
<li class="calibre3">如果类型推断得到的是实际类型<ul class="calibre20">
<li class="calibre3">那么类型中的实现将被调用；如果类型中没有实现，那么接口扩展中的默认实现被使用</li>
</ul>
</li>
<li class="calibre3">如果类型推断得到的是接口<ul class="calibre20">
<li class="calibre3">并且方法在接口中进行了定义，那么类型中的实现将被调用；如果类型中没有实现，那么接口扩展中的默认实现被使用</li>
<li class="calibre3">否则 (也就是方法没有在接口中定义)，扩展中的默认实现将被调用</li>
</ul>
</li>
</ul>

        
        </div>
    
</div>

        
        
    
    

</body></html>
