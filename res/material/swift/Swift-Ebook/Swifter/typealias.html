<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml" lang="zh-cn" xml:lang="zh-cn">
  <head>
    <title>typealias 和泛型接口 | Swifter - 100 个 Swift 必备 Tips (第二版)</title>
    <meta content="" name="description"/>
    <meta content="GitBook 2.2.0" name="generator"/>
    <meta content="王巍 (onevcat)" name="author"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="page_styles.css" rel="stylesheet" type="text/css"/>
</head>
  <body class="calibre">
        
        
<div class="page">
    <h1 class="book-chapter" id="calibre_toc_17">typealias 和泛型接口</h1>
    
        <div class="normal" id="section-">
        
            <h1 id="typealias-%E5%92%8C%E6%B3%9B%E5%9E%8B%E6%8E%A5%E5%8F%A3" class="calibre1">typealias 和泛型接口</h1>
<p class="calibre9">typealias 是用来为已经存在的类型重新定义名字的，通过命名，可以使代码变得更加清晰。使用的语法也很简单，使用 typealias 关键字像使用普通的赋值语句一样，可以将某个已经存在的类型赋值为新的名字。比如在计算二维平面上的距离和位置的时候，我们一般使用 <code class="calibre13 pcalibre6 pcalibre5">Double</code> 来表示距离，用 <code class="calibre13 pcalibre6 pcalibre5">CGPoint</code> 来表示位置：</p>
<pre class="calibre12"><code class="pcalibre3 lang-swift pcalibre4"><span class="hljs-func"><span class="hljs-keyword">func</span> <span class="hljs-title">distanceBetweenPoint</span><span class="hljs-params">(point: CGPoint, toPoint: CGPoint)</span></span> -&gt; <span class="hljs-func">Double</span> {
    <span class="hljs-keyword">let</span> dx = <span class="hljs-func">Double</span>(toPoint.x - point.x)
    <span class="hljs-keyword">let</span> dy = <span class="hljs-func">Double</span>(toPoint.y - point.y)
    <span class="hljs-keyword">return</span> sqrt(dx * dx + dy * dy)
}

<span class="hljs-keyword">let</span> origin: <span class="hljs-func">CGPoint</span> = <span class="hljs-func">CGPoint</span>(x: <span class="hljs-params">0</span>, y: <span class="hljs-params">0</span>)
<span class="hljs-keyword">let</span> point: <span class="hljs-func">CGPoint</span> = <span class="hljs-func">CGPoint</span>(x: <span class="hljs-params">1</span>, y: <span class="hljs-params">1</span>)

<span class="hljs-keyword">let</span> <span class="hljs-params">distance</span>: <span class="hljs-func">Double</span> =  distanceBetweenPoint(origin, point)
</code></pre>
<p class="calibre9">虽然在数学上和最后的程序运行上都没什么问题，但是阅读和维护的时候总是觉得有哪里不对。因为我们没有将数学抽象和实际问题结合起来，使得在阅读代码时我们还需要在大脑中进行一次额外的转换：<code class="calibre13 pcalibre6 pcalibre5">CGPoint</code> 代表一个点，而这个点就是我们在定义的坐标系里的<strong class="calibre10">位置</strong>；<code class="calibre13 pcalibre6 pcalibre5">Double</code> 是一个数字，它代表两个点之间的<strong class="calibre10">距离</strong>。</p>
<p class="calibre9">如果我们使用 typealias，就可以将这种转换直接写在代码里，从而减轻阅读和维护的负担：</p>
<pre class="calibre12"><code class="pcalibre3 lang-swift pcalibre4"><span class="hljs-keyword">import</span> <span class="hljs-func">UIKit</span>

<span class="hljs-keyword">typealias</span> <span class="hljs-func">Location</span> = <span class="hljs-func">CGPoint</span>
<span class="hljs-keyword">typealias</span> <span class="hljs-func">Distance</span> = <span class="hljs-func">Double</span>

<span class="hljs-func"><span class="hljs-keyword">func</span> <span class="hljs-title">distanceBetweenPoint</span><span class="hljs-params">(location: Location,
    toLocation: Location)</span></span> -&gt; <span class="hljs-func">Distance</span> {
        <span class="hljs-keyword">let</span> dx = <span class="hljs-func">Distance</span>(location.x - toLocation.x)
        <span class="hljs-keyword">let</span> dy = <span class="hljs-func">Distance</span>(location.y - toLocation.y)
        <span class="hljs-keyword">return</span> sqrt(dx * dx + dy * dy)
}

<span class="hljs-keyword">let</span> origin: <span class="hljs-func">Location</span> = <span class="hljs-func">Location</span>(x: <span class="hljs-params">0</span>, y: <span class="hljs-params">0</span>)
<span class="hljs-keyword">let</span> point: <span class="hljs-func">Location</span> = <span class="hljs-func">Location</span>(x: <span class="hljs-params">1</span>, y: <span class="hljs-params">1</span>)

<span class="hljs-keyword">let</span> <span class="hljs-params">distance</span>: <span class="hljs-func">Distance</span> =  distanceBetweenPoint(origin, toLocation: point)
</code></pre>
<p class="calibre9">同样的代码，在 typealias 的帮助下，读起来就轻松多了。可能单单这个简单例子不会有特别多的体会，但是当你遇到更复杂的实际问题时，你就可以不再关心并去思考自己代码里那些成堆的 <code class="calibre13 pcalibre6 pcalibre5">Int</code> 或者 <code class="calibre13 pcalibre6 pcalibre5">String</code> 之类的基本类型到底代表的是什么东西了，这样你应该能省下不少脑细胞。</p>
<p class="calibre9">对于普通类型并没有什么难点，但是在涉及到泛型时，情况就稍微不太一样。首先，typealias 是单一的，也就是说你必须指定将某个特定的类型通过 typealias 赋值为新名字，而不能将整个泛型类型进行重命名。下面这样的命名都是无法通过编译的：</p>
<blockquote class="calibre6">
<h3 id="%E8%BF%99%E6%98%AF%E9%94%99%E8%AF%AF%E4%BB%A3%E7%A0%81" class="calibre16">这是错误代码</h3>
<pre class="calibre14"><code class="pcalibre3 lang-swift pcalibre4"><span class="hljs-func"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span>&lt;<span class="hljs-title">T</span>&gt; </span>{}
<span class="hljs-keyword">typealias</span> <span class="hljs-func">Worker</span> = <span class="hljs-func">Person</span>
<span class="hljs-keyword">typealias</span> <span class="hljs-func">Worker</span> = <span class="hljs-func">Person</span>&lt;<span class="hljs-func">T</span>&gt;
<span class="hljs-keyword">typealias</span> <span class="hljs-func">Worker</span>&lt;<span class="hljs-func">T</span>&gt; = <span class="hljs-func">Person</span>&lt;<span class="hljs-func">T</span>&gt;
</code></pre>
</blockquote>
<p class="calibre9">一旦泛型类型的确定性得到保证后，我们就可以重命名了：</p>
<pre class="calibre12"><code class="pcalibre3 lang-swift pcalibre4"><span class="hljs-func"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span>&lt;<span class="hljs-title">T</span>&gt; </span>{}

<span class="hljs-keyword">typealias</span> <span class="hljs-func">WorkId</span> = <span class="hljs-func">String</span>
<span class="hljs-keyword">typealias</span> <span class="hljs-func">Worker</span> = <span class="hljs-func">Person</span>&lt;<span class="hljs-func">WorkId</span>&gt;
</code></pre>
<p class="calibre9">另一个值得一提的是 Swift 中是没有泛型接口的，但是使用 typealias，我们可以在接口里定义一个必须实现的别名，这在一定范围内也算一种折衷方案。比如在 <code class="calibre13 pcalibre6 pcalibre5">GeneratorType</code> 和 <code class="calibre13 pcalibre6 pcalibre5">SequenceType</code> 这两个接口中，Swift 都用到了这个技巧，来为接口确定一个使用的类似泛型的特性：</p>
<pre class="calibre12"><code class="pcalibre3 lang-swift pcalibre4"><span class="hljs-func"><span class="hljs-keyword">protocol</span> <span class="hljs-title">GeneratorType</span> </span>{
    <span class="hljs-keyword">typealias</span> <span class="hljs-func">Element</span>
    <span class="hljs-keyword">mutating</span> <span class="hljs-func"><span class="hljs-keyword">func</span> <span class="hljs-title">next</span><span class="hljs-params">()</span></span> -&gt; <span class="hljs-func">Self</span>.<span class="hljs-func">Element</span>?
}

<span class="hljs-func"><span class="hljs-keyword">protocol</span> <span class="hljs-title">SequenceType</span> </span>{
    <span class="hljs-keyword">typealias</span> <span class="hljs-func">Generator</span> : <span class="hljs-func">GeneratorType</span>
    <span class="hljs-func"><span class="hljs-keyword">func</span> <span class="hljs-title">generate</span><span class="hljs-params">()</span></span> -&gt; <span class="hljs-func">Self</span>.<span class="hljs-func">Generator</span>
}
</code></pre>
<p class="calibre9">在实现这些接口时，我们不仅需要实现指定的方法，还要实现对应的 typealias，这其实是一种对于接口适用范围的抽象和约束。</p>

        
        </div>
    
</div>

        
        
    
    

</body></html>
