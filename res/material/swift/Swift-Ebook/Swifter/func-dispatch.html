<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml" lang="zh-cn" xml:lang="zh-cn">
  <head>
    <title>实例方法的动态调用 | Swifter - 100 个 Swift 必备 Tips (第二版)</title>
    <meta content="" name="description"/>
    <meta content="GitBook 2.2.0" name="generator"/>
    <meta content="王巍 (onevcat)" name="author"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="page_styles.css" rel="stylesheet" type="text/css"/>
</head>
  <body class="calibre">
        
        
<div class="page">
    <h1 class="book-chapter" id="calibre_toc_44">实例方法的动态调用</h1>
    
        <div class="normal" id="section-">
        
            <h1 id="%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95%E7%9A%84%E5%8A%A8%E6%80%81%E8%B0%83%E7%94%A8" class="calibre1">实例方法的动态调用</h1>
<p class="calibre9">在 Swift 中有一类很有意思的写法，可以让我们不直接使用实例来调用这个实例上的方法，而是通过类型取出这个类型的某个实例方法的签名，然后再通过传递实例来拿到实际需要调用的方法。比如我们有这样的定义：</p>
<pre class="calibre12"><code class="pcalibre3 lang-swift pcalibre4"><span class="hljs-func"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span> </span>{
    <span class="hljs-func"><span class="hljs-keyword">func</span> <span class="hljs-title">method</span><span class="hljs-params">(number: Int)</span></span> -&gt; <span class="hljs-func">Int</span> {
        <span class="hljs-keyword">return</span> number + <span class="hljs-params">1</span>
    }
}
</code></pre>
<p class="calibre9">想要调用 <code class="calibre13 pcalibre6 pcalibre5">method</code> 方法的话，最普通的使用方式是生成 <code class="calibre13 pcalibre6 pcalibre5">MyClass</code> 的实例，然后用 <code class="calibre13 pcalibre6 pcalibre5">.method</code> 来调用它：</p>
<pre class="calibre12"><code class="pcalibre3 lang-swift pcalibre4"><span class="hljs-keyword">let</span> object = <span class="hljs-func">MyClass</span>()
<span class="hljs-keyword">let</span> result = object.method(<span class="hljs-params">1</span>)

<span class="hljs-title">// result = 2</span>
</code></pre>
<p class="calibre9">这就限定了我们只能够在编译的时候就决定 <code class="calibre13 pcalibre6 pcalibre5">object</code> 实例和对应的方法调用。其实我们还可以使用刚才说到的方法，将上面的例子改写为：</p>
<pre class="calibre12"><code class="pcalibre3 lang-swift pcalibre4"><span class="hljs-keyword">let</span> f = <span class="hljs-func">MyClass</span>.method
<span class="hljs-keyword">let</span> object = <span class="hljs-func">MyClass</span>()
<span class="hljs-keyword">let</span> result = f(object)(<span class="hljs-params">1</span>)
</code></pre>
<p class="calibre9">这种语法看起来会比较奇怪，但是实际上并不复杂。Swift 中可以直接用 <code class="calibre13 pcalibre6 pcalibre5">Type.instanceMethod</code> 的语法来生成一个可以<a href="currying.html" class="pcalibre pcalibre2 pcalibre1 calibre4">柯里化</a>的方法。如果我们观察 <code class="calibre13 pcalibre6 pcalibre5">f</code> 的类型 (Alt + 单击)，可以知道它是：</p>
<pre class="calibre12"><code class="pcalibre3 lang-swift pcalibre4">f: <span class="hljs-func">MyClass</span> -&gt; (<span class="hljs-func">Int</span>) -&gt; <span class="hljs-func">Int</span>
</code></pre>
<p class="calibre9">其实对于 <code class="calibre13 pcalibre6 pcalibre5">Type.instanceMethod</code> 这样的取值语句，实际上刚才</p>
<pre class="calibre12"><code class="pcalibre3 lang-swift pcalibre4"><span class="hljs-keyword">let</span> f = <span class="hljs-func">MyClass</span>.method
</code></pre>
<p class="calibre9">做的事情是类似于下面这样的字面量转换：</p>
<pre class="calibre12"><code class="pcalibre3 lang-swift pcalibre4"><span class="hljs-keyword">let</span> f = { (obj: <span class="hljs-func">MyClass</span>) <span class="hljs-keyword">in</span> obj.method }
</code></pre>
<p class="calibre9">这下就不难理解为什么上面的调用方法可以成立了。</p>
<p class="calibre9">这种方法只适用于实例方法，对于属性的 getter 或者 setter 是不能用类似的写法的。另外，如果我们遇到有类型方法的名字冲突时：</p>
<pre class="calibre12"><code class="pcalibre3 lang-swift pcalibre4"><span class="hljs-func"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span> </span>{
    <span class="hljs-func"><span class="hljs-keyword">func</span> <span class="hljs-title">method</span><span class="hljs-params">(number: Int)</span></span> -&gt; <span class="hljs-func">Int</span> {
        <span class="hljs-keyword">return</span> number + <span class="hljs-params">1</span>
    }

    <span class="hljs-func"><span class="hljs-keyword">class</span> <span class="hljs-title">func</span> <span class="hljs-title">method</span>(<span class="hljs-title">number</span>: <span class="hljs-title">Int</span>) -&gt; <span class="hljs-title">Int</span> </span>{
        <span class="hljs-keyword">return</span> number
    }
}
</code></pre>
<p class="calibre9">如果不加改动，<code class="calibre13 pcalibre6 pcalibre5">MyClass.method</code> 将取到的是类型方法，如果我们想要取实例方法的话，可以显式地加上类型声明加以区别。这种方式不仅在这里有效，在其他大多数名字有歧义的情况下，都能很好地解决问题：</p>
<pre class="calibre12"><code class="pcalibre3 lang-swift pcalibre4"><span class="hljs-keyword">let</span> f1 = <span class="hljs-func">MyClass</span>.method
<span class="hljs-title">// class func method 的版本</span>

<span class="hljs-keyword">let</span> f2: <span class="hljs-func">Int</span> -&gt; <span class="hljs-func">Int</span> = <span class="hljs-func">MyClass</span>.method
<span class="hljs-title">// 和 f1 相同</span>

<span class="hljs-keyword">let</span> f3: <span class="hljs-func">MyClass</span> -&gt; <span class="hljs-func">Int</span> -&gt; <span class="hljs-func">Int</span> = <span class="hljs-func">MyClass</span>.method
<span class="hljs-title">// func method 的柯里化版本</span>
</code></pre>

        
        </div>
    
</div>

        
        
    
    

</body></html>
