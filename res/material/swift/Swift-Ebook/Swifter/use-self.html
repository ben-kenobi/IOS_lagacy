<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml" lang="zh-cn" xml:lang="zh-cn">
  <head>
    <title>接口和类方法中的 Self | Swifter - 100 个 Swift 必备 Tips (第二版)</title>
    <meta content="" name="description"/>
    <meta content="GitBook 2.2.0" name="generator"/>
    <meta content="王巍 (onevcat)" name="author"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="page_styles.css" rel="stylesheet" type="text/css"/>
</head>
  <body class="calibre">
        
        
<div class="page">
    <h1 class="book-chapter" id="calibre_toc_30">接口和类方法中的 Self</h1>
    
        <div class="normal" id="section-">
        
            <h1 id="%E6%8E%A5%E5%8F%A3%E5%92%8C%E7%B1%BB%E6%96%B9%E6%B3%95%E4%B8%AD%E7%9A%84-self" class="calibre1">接口和类方法中的 Self</h1>
<p class="calibre9">我们在看一些接口的定义时，可能会注意到出现了首字母大写的 <code class="calibre13 pcalibre6 pcalibre5">Self</code> 出现在类型的位置上：</p>
<pre class="calibre12"><code class="pcalibre3 lang-swift pcalibre4"><span class="hljs-func"><span class="hljs-keyword">protocol</span> <span class="hljs-title">IntervalType</span> </span>{
    <span class="hljs-title">//...</span>

    <span class="hljs-title">/// Return `rhs` clamped to `self`.  The bounds of the result, even</span>
    <span class="hljs-title">/// if it is empty, are always within the bounds of `self`</span>
    <span class="hljs-func"><span class="hljs-keyword">func</span> <span class="hljs-title">clamp</span><span class="hljs-params">(intervalToClamp: <span class="hljs-keyword">Self</span>)</span></span> -&gt; <span class="hljs-func">Self</span>

    <span class="hljs-title">//...</span>
}
</code></pre>
<p class="calibre9">比如上面这个 <code class="calibre13 pcalibre6 pcalibre5">IntervalType</code> 的接口定义了一个方法，接受实现该接口的自身的类型，并返回一个同样的类型。</p>
<p class="calibre9">这么定义是因为接口其实本身是没有自己的上下文类型信息的，在声明接口的时候，我们并不知道最后究竟会是什么样的类型来实现这个接口，Swift 中也不能在接口中定义泛型进行限制。而在声明接口时，我们希望在接口中使用的类型就是实现这个接口本身的类型的话，就需要使用 <code class="calibre13 pcalibre6 pcalibre5">Self</code> 进行指代。</p>
<p class="calibre9">但是在这种情况下，<code class="calibre13 pcalibre6 pcalibre5">Self</code> 不仅指代的是实现该接口的类型本身，也包括了这个类型的子类。从概念上来说，<code class="calibre13 pcalibre6 pcalibre5">Self</code> 十分简单，但是实际实现一个这样的方法却稍微要转个弯。为了说明这个问题，我们假设要实现一个 <code class="calibre13 pcalibre6 pcalibre5">Copyable</code> 的接口，满足这个接口的类型需要返回一个和接受方法调用的实例相同的拷贝。一开始我们可能考虑的接口是这样的：</p>
<pre class="calibre12"><code class="pcalibre3 lang-swift pcalibre4"><span class="hljs-func"><span class="hljs-keyword">protocol</span> <span class="hljs-title">Copyable</span> </span>{
    <span class="hljs-func"><span class="hljs-keyword">func</span> <span class="hljs-title">copy</span><span class="hljs-params">()</span></span> -&gt; <span class="hljs-func">Self</span>
}
</code></pre>
<p class="calibre9">这是很直接明了的，它应该做的是创建一个和接受这个方法的对象同样的东西，然后将其返回，返回的类型不应该发生改变，所以写为 <code class="calibre13 pcalibre6 pcalibre5">Self</code>。然后开始尝试实现一个 <code class="calibre13 pcalibre6 pcalibre5">MyClass</code> 来满足这个接口：</p>
<pre class="calibre12"><code class="pcalibre3 lang-swift pcalibre4"><span class="hljs-func"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span>: <span class="hljs-title">Copyable</span> </span>{

    <span class="hljs-keyword">var</span> num = <span class="hljs-params">1</span>

    <span class="hljs-func"><span class="hljs-keyword">func</span> <span class="hljs-title">copy</span><span class="hljs-params">()</span></span> -&gt; <span class="hljs-func">Self</span> {
        <span class="hljs-title">// <span class="hljs-func"><span class="hljs-keyword">TODO</span></span>: 返回什么？</span>
        <span class="hljs-title">// return</span>
    }
}
</code></pre>
<p class="calibre9">我们一开始的时候可能回写类似这样的代码：</p>
<blockquote class="calibre6">
<h3 id="%E8%BF%99%E6%98%AF%E9%94%99%E8%AF%AF%E4%BB%A3%E7%A0%81" class="calibre16">这是错误代码</h3>
<pre class="calibre14"><code class="pcalibre3 lang-swift pcalibre4">func copy() -&gt; Self {
    let result = MyClass()
    result.num = num
    return result
}
</code></pre></blockquote>
<p class="calibre9">但是显然类型是有问题的，因为该方法要求返回一个抽象的、表示当前类型的 <code class="calibre13 pcalibre6 pcalibre5">Self</code>，但是我们却返回了它的真实类型 <code class="calibre13 pcalibre6 pcalibre5">MyClass</code>，这导致了无法编译。也许你会尝试把方法声明中的 <code class="calibre13 pcalibre6 pcalibre5">Self</code> 改为 <code class="calibre13 pcalibre6 pcalibre5">MyClass</code>，这样声明就和实际返回一致了，但是很快你会发现这样的话，实现的方法又和接口中的定义不一样了，依然不能编译。</p>
<p class="calibre9">为了解决这个问题，我们在这里需要的是通过一个和当前上下文 (也就是和 <code class="calibre13 pcalibre6 pcalibre5">MyClass</code>) 无关的，又能够指代当前类型的方式进行初始化。希望你还能记得我们在<a href="instance-type.html" class="pcalibre pcalibre2 pcalibre1 calibre4">对象类型</a>中所提到的 <code class="calibre13 pcalibre6 pcalibre5">dynamicType</code>，这里我们就可以使用它来做初始化，以保证方法与当前类型上下文无关，这样不论是 <code class="calibre13 pcalibre6 pcalibre5">MyClass</code> 还是它的子类，都可以正确地返回合适的类型满足 <code class="calibre13 pcalibre6 pcalibre5">Self</code> 的要求：</p>
<pre class="calibre12"><code class="pcalibre3 lang-swift pcalibre4"><span class="hljs-func"><span class="hljs-keyword">func</span> <span class="hljs-title">copy</span><span class="hljs-params">()</span></span> -&gt; <span class="hljs-func">Self</span> {
    <span class="hljs-keyword">let</span> result = <span class="hljs-keyword">self</span>.<span class="hljs-keyword">dynamicType</span>.<span class="hljs-keyword">init</span>()
    result.num = num
    <span class="hljs-keyword">return</span> result
}
</code></pre>
<p class="calibre9">但是很不幸，单单是这样还是无法通过编译，编译器提示我们如果想要构建一个 <code class="calibre13 pcalibre6 pcalibre5">Self</code> 类型的对象的话，需要有 <a href="designated-convenience.html" class="pcalibre pcalibre2 pcalibre1 calibre4"><code class="calibre13 pcalibre6 pcalibre5">required</code> 关键字</a>修饰的初始化方法，这是因为 Swift 必须保证当前类和其子类都能响应这个 <code class="calibre13 pcalibre6 pcalibre5">init</code> 方法。在这个例子中，我们添加上一个 <code class="calibre13 pcalibre6 pcalibre5">required</code> 的 <code class="calibre13 pcalibre6 pcalibre5">init</code> 就行了。最后，<code class="calibre13 pcalibre6 pcalibre5">MyClass</code> 类型是这样的：</p>
<pre class="calibre12"><code class="pcalibre3 lang-swift pcalibre4"><span class="hljs-func"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span>: <span class="hljs-title">Copyable</span> </span>{

    <span class="hljs-keyword">var</span> num = <span class="hljs-params">1</span>

    <span class="hljs-func"><span class="hljs-keyword">func</span> <span class="hljs-title">copy</span><span class="hljs-params">()</span></span> -&gt; <span class="hljs-func">Self</span> {
        <span class="hljs-keyword">let</span> result = <span class="hljs-keyword">self</span>.<span class="hljs-keyword">dynamicType</span>.<span class="hljs-keyword">init</span>()
        result.num = num
        <span class="hljs-keyword">return</span> result
    }

    required <span class="hljs-keyword">init</span>() {

    }
}
</code></pre>
<p class="calibre9">我们可以通过测试来验证一下行为的正确性：</p>
<pre class="calibre12"><code class="pcalibre3 lang-swift pcalibre4"><span class="hljs-keyword">let</span> object = <span class="hljs-func">MyClass</span>()
object.num = <span class="hljs-params">100</span>

<span class="hljs-keyword">let</span> newObject = object.copy()
object.num = <span class="hljs-params">1</span>

<span class="hljs-params">print</span>(object.num)     <span class="hljs-title">// 1</span>
<span class="hljs-params">print</span>(newObject.num)  <span class="hljs-title">// 100</span>
</code></pre>
<p class="calibre9">而对于 <code class="calibre13 pcalibre6 pcalibre5">MyClass</code> 的子类，<code class="calibre13 pcalibre6 pcalibre5">copy()</code> 方法也能正确地返回子类的经过拷贝的对象了。</p>
<p class="calibre9">另一个可以使用 <code class="calibre13 pcalibre6 pcalibre5">Self</code> 的地方是在类方法中，使用起来也十分相似，核心就在于保证子类也能返回恰当的类型。</p>

        
        </div>
    
</div>

        
        
    
    

</body></html>
